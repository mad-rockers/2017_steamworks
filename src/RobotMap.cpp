// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"
#include "WPILib.h"
#include "AnalogPotentiometer.h"
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
std::shared_ptr<SpeedController> RobotMap::driveTrainRightController;
std::shared_ptr<SpeedController> RobotMap::driveTrainLeftController;
std::shared_ptr<SpeedController> RobotMap::gearGrab1Motor;
std::shared_ptr<SpeedController> RobotMap::gearGrab2Motor;


std::shared_ptr<SpeedController> RobotMap::Gear_Grab_Left_Wing;
std::shared_ptr<SpeedController> RobotMap::Gear_Grab_Right_Wing;


std::shared_ptr<RobotDrive> RobotMap::driveTrainRobotDrive;
std::shared_ptr<Encoder> RobotMap::driveTrainLeftEncoder;
std::shared_ptr<Encoder> RobotMap::driveTrainRightEncoder;
std::shared_ptr<Encoder> RobotMap::gearGrab1;
std::shared_ptr<Encoder> RobotMap::gearGrab2;
std::shared_ptr<SpeedController> RobotMap::shooterMotor;
std::shared_ptr<AnalogPotentiometer> RobotMap::gearGrabPot;
std::shared_ptr<SpeedController> RobotMap::gearLiftMotor;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION

void RobotMap::init() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    LiveWindow *lw = LiveWindow::GetInstance();
//Drive train
    driveTrainRightController.reset(new VictorSP(0));
    lw->AddActuator("DriveTrain", "Right Controller", std::static_pointer_cast<VictorSP>(driveTrainRightController));
    
    driveTrainLeftController.reset(new VictorSP(1));
    lw->AddActuator("DriveTrain", "Left Controller", std::static_pointer_cast<VictorSP>(driveTrainLeftController));

    driveTrainRobotDrive.reset(new RobotDrive(driveTrainLeftController, driveTrainRightController));
    
    driveTrainRobotDrive->SetSafetyEnabled(true);
        driveTrainRobotDrive->SetExpiration(0.1);
        driveTrainRobotDrive->SetSensitivity(0.5);
        driveTrainRobotDrive->SetMaxOutput(1.0);
//Shooter
    shooterMotor.reset(new VictorSP(3));
        lw->AddActuator("ShooterMotor", "ShooterMotor", std::static_pointer_cast<VictorSP>(shooterMotor));
//Gear Grabo

        gearGrab1Motor.reset(new VictorSP(5));
        lw->AddActuator("GearGrab", "gearGrab1Motor", std::static_pointer_cast<VictorSP>(gearGrab1Motor));

        gearGrab2Motor.reset(new VictorSP(6));
        lw->AddActuator("GearGrab", "gearGrab2Motor", std::static_pointer_cast<VictorSP>(gearGrab2Motor));

        //OLD MOVE driveTrainRobotDrive->SetInvertedMotor(RobotDrive::kRearRightMotor, true);




        driveTrainLeftEncoder.reset(new Encoder(4, 5, false, Encoder::k4X));
        lw->AddSensor("DriveTrain", "LeftEncoder", driveTrainLeftEncoder);
        driveTrainLeftEncoder->SetDistancePerPulse(1.0);
        driveTrainLeftEncoder->SetPIDSourceType(PIDSourceType::kRate);
        //Left always needs *-1 on distance

        driveTrainRightEncoder.reset(new Encoder(6, 7, false, Encoder::k4X));
        lw->AddSensor("DriveTrain", "RightEncoder", driveTrainRightEncoder);
        driveTrainRightEncoder->SetDistancePerPulse(1.0);
        driveTrainRightEncoder->SetPIDSourceType(PIDSourceType::kRate);



//Gear Grab Encoders
        gearGrab1.reset(new Encoder(8, 9, false, Encoder::k4X));
        lw->AddSensor("GearGrab1", "GearGrab1", gearGrab1);
        gearGrab1->SetDistancePerPulse(1.0);
        gearGrab1->SetPIDSourceType(PIDSourceType::kRate);

        gearGrab2.reset(new Encoder(1, 2, false, Encoder::k4X));
        lw->AddSensor("GearGrab2", "GearGrab2", gearGrab2);
        gearGrab2->SetDistancePerPulse(1.0);
        gearGrab2->SetPIDSourceType(PIDSourceType::kRate);
//Gear Lift Motor Controller
        gearLiftMotor.reset(new VictorSP(4));
        lw->AddActuator("gearLift", "Motor", std::static_pointer_cast<VictorSP>(gearLiftMotor));
        //Pots

        gearGrabPot.reset(new AnalogPotentiometer(3,360,0.0));
        lw->AddSensor("Pots", "GEARGRABPOT", gearGrabPot);


    // END AUTOGENERATEDNO CODE, SOURCE=ROBOTBUILDERNO ID=CONSTRUCTORSNOOOOOOOOOOOOOO
}
